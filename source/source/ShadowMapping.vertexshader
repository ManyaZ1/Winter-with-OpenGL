#version 330 core

layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexNormal_modelspace;
layout(location = 2) in vec2 vertexUV;


// Phong 
// light properties
struct Light {
    vec4 La;
    vec4 Ld;
    vec4 Ls;
    vec3 lightPosition_worldspace;
};
uniform Light light;
uniform float scaling_factor;
uniform mat4 P;
uniform mat4 V;
uniform mat4 M;

uniform mat4 lightVP;
uniform mat4 light2VP; // hw 2
out vec4 light_position_cameraspace2;
uniform Light light2; 
out vec4 vertex_position_cameraspace;
out vec4 vertex_normal_cameraspace;
out vec4 light_position_cameraspace;
out vec2 vertex_UV;
out vec4 vertex_position_lightspace;
out vec4 vertex_position_lightspace2;
out vec2 worldUV;
uniform float normDir;
uniform vec2 uvScale; 
out vec2 vertex_UV_tiled;
out vec3 fragPos_modelspace;
uniform int useTexture;

// Source - https://stackoverflow.com/a
// Posted by HuaTham, modified by community. See post 'Timeline' for change history
// Retrieved 2025-12-07, License - CC BY-SA 3.0

float atan2(in float y, in float x)
{
    float PI = 3.14159265359;
    bool s = (abs(x) > abs(y));
    return x == 0.0 ? sign(y)*PI/2 : atan(y, x);
    //return mix(PI/2.0 - atan(x,y), atan(y,x), s);
}



void main() {
   if (useTexture == 3) {
        // position for rasterizer
        gl_Position = P * V * M * vec4(vertexPosition_modelspace, 1.0);

        // pass model-space position to fragment so we can compute UVs per-fragment
        fragPos_modelspace = vertexPosition_modelspace;

        //  vertex_UV as placeholder but but not used 
        vertex_UV = vec2(0.0);
        return;
    }
    /*if (useTexture == 3) {
        gl_Position =  P * V * M * vec4(vertexPosition_modelspace, 1);
    
        vec3 normPos = normalize(vertexPosition_modelspace);
        float pi = 3.14159265359;

        // Stable spherical mapping with no seams
        vertex_UV.x = clamp(atan2(normPos.z, normPos.x+1e-8) / (2.0 * pi) + 0.5,-1.0, 1.0  );

        // Prevent asin precision issues at horizon
        float y = clamp(normPos.y, -1.0, 1.0);
        vertex_UV.y = (asin(y) / pi + 0.5);
    }*/
    
/*if (useTexture == 3) {
    gl_Position =  P * V * M * vec4(vertexPosition_modelspace, 1);
    
    vec3 normPos = normalize(vertexPosition_modelspace);
    float pi = 3.14159265359;

    // Stable spherical mapping with no seams
    vertex_UV.x = clamp(atan2(normPos.z, normPos.x+1e-8) / (2.0 * pi) + 0.5,-1.0, 1.0  );

    // Prevent asin precision issues at horizon
    float y = clamp(normPos.y, -1.0, 1.0);
    vertex_UV.y = (asin(y) / pi + 0.5);
    
    // Optional: force wrap cleanly
    //vertex_UV.y = fract(vertex_UV.y);
    }*/
//if (useTexture == 3) {
//    gl_Position =  P * V * M * vec4(vertexPosition_modelspace, 1);
//    
//    // Generate spherical UVs for sky dome
//    vec3 normPos = normalize(vertexPosition_modelspace);
//    
//    // Better spherical mapping
//    float pi = 3.14159265359;
//    //pi = 3.0f;
//    if (abs(normPos.x)< 0.0001 && abs(normPos.z)<0.0001)    {
//        vertex_UV.x = 0.5;
//        vertex_UV.y = 0.5 + asin(normPos.y) / pi;
//    }
//    else{
//        vertex_UV.x = 0.5 + atan(normPos.x, normPos.z) / (2.0 * pi);
//        vertex_UV.y = 0.5 + asin(normPos.y) / pi;
//    }    return;}
    

    else {
        
    // Output position of the vertex
    gl_Position =  P * V * M * vec4(vertexPosition_modelspace, 1);
    
    // FS
    vertex_position_cameraspace = V * M * vec4(vertexPosition_modelspace, 1);
    //vertex_normal_cameraspace = V * M * vec4(vertexNormal_modelspace, 0);
    vertex_normal_cameraspace = V * M * vec4(vertexNormal_modelspace * normDir, 0);
    light_position_cameraspace = V * vec4(light.lightPosition_worldspace, 1);
    vertex_UV = vertexUV; //?
    vertex_UV_tiled = vertexUV * uvScale;

    // Task 4.2

    vertex_position_lightspace = lightVP*M*vec4(vertexPosition_modelspace, 1); //pame sto world space kai meta sto light space

    // light space 2
    light_position_cameraspace2 = V * vec4(light2.lightPosition_worldspace, 1);
    vertex_position_lightspace2 = light2VP * M * vec4(vertexPosition_modelspace, 1);
    }
}